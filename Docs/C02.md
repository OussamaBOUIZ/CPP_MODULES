# Why we need a Canonical Class Form ?
Whenever a class is containing pointers to block of memory in the heap, Copying objects instantiated from that class either by the default copy constructor or the default copy assignment operator are both inadequate. So supplying our class with four conventional member functions, would be beneficial to reach a sufficient copy control. These four member functions are:
* A Constructor 
* A Destructor
* A Copy Constructor
* A Copy Assignment Operator

## What is a Copy Constructor ??

Whenever our code contains a set of instructions that requires the creation of a copy of our objects the copy constructor gets called. Well this copy constructor is not alwasys defined by the programmer, there's a so-called synthesized copy constructor that the compiler synthesize and it's known of yielding a shallow copy. This shallow copy does not always satisfy our needs and hence the definition of a copy constructor is crucial.

One of those lines of code that requires the creation of copy, the following:
* Initializing an object through the "=" operator with another object of the same type.
* Returning a given object from a function.
* or passing an object to a function.

Just by playing around with some cpp code we can observe, that: 
If we have declared a copy constructor inside our class, and we don't define it, a case of the ones above yields a compilation error telling that `Undefined Refrence to [copy constructor prototype]`. When in fact, the absence of a declared copy constructor will compile flawlessly. The thing is that the compiler will synthesize a **Default Copy Constructor**. 

A call to the copy constructor will always have place, when the creation of copy has place. But we some distinguish different cases here:
### The absence of a defined copy constructor:
There'll be a call to the default copy constructor, which will give birth of a shallow copy. This copying procedure will be flawed, for instance in the presence of a dynamic allocation of memory, just the pointers get copied and not their emplacement in the memory, the first issue to care about is the occurence of a *double free* while destroying the object.
### The existence of a defined copy constructor:
From our code we can define a copy constructor, it is a public member function that has the same name as the constructor, that takes a const or nonconst reference to the object it's copying. This time there's no shallow copy, the defined copy constructor takes care of all the job. Setting this member function to private will cause compilation errors.

## Comments:
> C++ imposes that the sole argument of the copy constructor is passed by reference. This makes sense as passing by value will issue a call to the copy constructor itself so this declaration : Student( Student ) is incorrect.

> Knowing that a copy constructor can have both prototypes *Student( Student &)* and *Student (const Student &)* and could both have place inside a class. All in all, a copy constructor will usualy be reading the object it's copying and it will not overwrite the object. So it fully makes sense that the sole argument of this constructor to be a const reference.

## What is a Copy Assignment Operator : 
A copy assignment operator is a function that controls how objects of its class are assigned, This operator is used whenever we proceed for assignment of an object with another object of the same class. Similarly to the copy constructor if we did not **overload** the "=" operator the compiler will generate automatically a **synthesized copy assignment operator**. This synthesized opearator assing an object to another one by copying the value of each member to the corresponding member in the other object. Well, how a copy assignment operator is declared inside a class ? In fact the common used 
expression for this operation is called **Overloading an Operator**. 


## What are Overloaded Operators ? 
Generally, **Overloaded Operators** are just another member function named `operator[operatorSymbol]` for example `operator=`, that redefine or let's say reshape the behavior of an operator such us "=, []...". The operands of the operator constitute the parameters of this function, being a member function, the left-hand operand is bound to the implicit *this* parameter, the right-hand operand is passed explicitly as a parameter.

> What Does mean memberwise copy ??
> A memberwise copy is a copy that requires an intimate knowledge of the structure of the data that it's being copied.
