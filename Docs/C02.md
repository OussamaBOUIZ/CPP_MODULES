# Why we need a Canonical Class Form ?
Whenever a class is containing pointers to block of memory in the heap, Copying objects instantiated from that class either by the default copy constructor or the default copy assignment operator are both inadequate. So supplying our class with four conventional member functions, would be beneficial to reach a sufficient copy control. These four member functions are:
* A Constructor 
* A Destructor
* A Copy Constructor
* A Copy Assignment Operator

## What is a Copy Constructor ??

Whenever our code contains a set of instructions that requires the creation of a copy of our objects the copy constructor gets called. Well this copy constructor is not alwasys defined by the programmer, there's a so-called synthesized copy constructor that the compiler synthesize and it's known of yielding a shallow copy. This shallow copy does not always satisfy our needs and hence the definition of a copy constructor is crucial.

One of those lines of code that requires the creation of copy, the following:
* Initializing an object through the "=" operator with another object of the same type.
* Returning a given object from a function.
* or passing an object to a function.

Just by playing around with some cpp code we can observe, that: 
If we have declared a copy constructor inside our class, and we don't define it, a case of the ones above yields a compilation error telling that `Undefined Refrence to [copy constructor prototype]`. When in fact, the absence of a declared copy constructor will compile flawlessly. The thing is that the compiler will synthesize a **Default Copy Constructor**. 

A call to the copy constructor will always have place, when the creation of copy has place. But we distinguish some different cases here:
### The absence of a defined copy constructor:
There'll be a call to the default copy constructor, which will give birth of a shallow copy. This copying procedure will be flawed, for instance in the presence of a dynamic allocation of memory, just the pointers get copied and not their emplacement in the memory, the first issue to care about is the occurence of a *double free* while destroying the object.
### The existence of a defined copy constructor:
From our code we can define a copy constructor, it is a public member function that has the same name as the constructor, that takes a const or nonconst reference to the object it's copying. This time there's no shallow copy, the defined copy constructor takes care of all the job. Setting this member function to private will cause compilation errors.

## Comments:
> C++ imposes that the sole argument of the copy constructor is passed by reference. This makes sense as passing by value will issue a call to the copy constructor itself so this declaration : Student( Student ) is incorrect.

> Knowing that a copy constructor can have both prototypes *Student( Student &)* and *Student (const Student &)* and could both have place inside a class. All in all, a copy constructor will usualy be reading the object it's copying and it will not overwrite the object. So it fully makes sense that the sole argument of this constructor to be a const reference.

## What is a Copy Assignment Operator : 
A copy assignment operator is a function that controls how objects of its class are assigned, This operator is used whenever we proceed for assignment of an object with another object of the same class. Similarly to the copy constructor if we did not **overload** the "=" operator the compiler will generate automatically a **synthesized copy assignment operator**. This synthesized opearator assing an object to another one by copying the value of each member to the corresponding member in the other object. Well, how a copy assignment operator is declared inside a class ? In fact the common used 
expression for this operation is called **Overloading an Operator**. 


## What are Overloaded Operators ? 
Generally, **Overloaded Operators** are just another member function named `operator[operatorSymbol]` for example `operator=`, that redefine or let's say reshape the behavior of an operator such us "=, []...". The operands of the operator constitute the parameters of this function, being a member function, the left-hand operand is bound to the implicit *this* parameter, the right-hand operand is passed explicitly as a parameter.

# Fixed-Point An Overwhelming Topic:
In general, floating point math offers a wider range of numbers and more precision than fixed point math. A fundamental difference between the two is the location of the decimal point, fixed-point numbers have the decimal point in a fixed position.
Fixed point number have a certain number of reserved digits that are on the left-side of the decimal for the integer portion of the number, the number to the right of the decimal point are reserved for the fractional portion of the number.
In the fixed-point representation, the fraction is often represented in the same number base as the integer part, but using negative powers of the base *b*. If n fraction digits are stored, the value will always be an integer multiple of b<sup color="blue">-n</sup>. 

 ## Accuracy Vs Precision --> Integers vs Floating point numbers
Accuracy referes to how close the measurment is to the true value.
Precision has to do with how much information you have about a quantity, how uniquely you have it pinned down.
Integers cannot keep track of the fractional part, dividing 5 or 4 by 2 will both yield 2. Whereas, for example an integer that is equal to 6 is undisputably 6 at the dot.
So we could say that integers gain in terms of accuracy but lack precision.
In the other hand, floating point are very precise, since they never delibrately discard informations representing your numbers, but floating point have poor accuracy. 
We could say that integers and floating-point numbers are different in terms that not every fraction can be represented in binary, meanwhile we could represent any integer in binary. The cause is not the base two, this could be noticeable even in base 10 for example 1/3. 

Real numbers cannot be represented accurately in a fixed space, when operating with floating-point numbers the result may not be fully represented with the required precision. This inaccuracy ends up with an information loss.




## A look on the implementation of the Fixed Class:
This Class has two parameterized constructor one that takes in a const integer and another one that takes in a const float, both will have to convert the passed argument to the corresponding fixed point number. Well this is achievable by shifting the given integer number to the left by a specified amount of bit, in our case we have an attribute named `fractionalBits` storing this amount which is 8. But wait why would we do so ?? 
In fact, our class named Fixed is devised to represent a fixed-point number, that is designating 8 bits for the fractional part in its bitstring. Well before explaining what does this mean, let's discuss What the naming refers to :
We actually assume that there is an imaginary binary point that seperates the integer from the fractional part, the position of this binary point is **FIXED** hence the naminng, and it's indicating how many bits were attributed to represent the integer part, and how many for the fractional part. For example a binary point fixed on the 3rd bit will let us with 2 bits for the fractional part, if it is fixed on the least significant bit we will be left with 0 bit s for the fraction and in this case it'll be an ordinary integer. In this regards integers are just a special case of the fixed-point.
Back to our question. Well let's assume we did this on base 10, we got two numbers a and b, as a=10.45 and b=33.12, to make the calculation of their product easier let's get rid of that point, so that we have 1045 * 3312 what we did here is:
a = 10.45 * 10<sup>2</sup> = 1045 and b =  33.12 * 10<sup>2</sup> = 3312, obviously we transformed a floating-point numbers calculation to an easy integers calcualtions, getting rid of that point overhead. We could do the same thing on a binary base, in which 10 is 2. And that is simply shifting to the left, we just multiply our floating-point number by 2<sup>a_given_value</sup>. In other hand shifting to the right is dividing by 2<sup>a_given_value</sup>. Well how is this relevant to fixed-point numbers. Well The thing is fixed-point was invented to alternate the floating-point with the purpose of making calculations easier in a certain context. When we shift a floating point a certain amount of bits we implicity indicate that these bits are presumably apportioned for the fraction of this number.
The class `Fixed` holds inside it informations about the number, and the fraction bits, in addition to a set of member functions to manipulate these informations.


# Overloading Operators:
In C++, we commonly need to **REDEFINE** existing operators to meet our needs, this redefinition is pointed out to as **OVERLOADING**, which is an instance of **ad-hoc polymorphism**. An overloaded operator function has simply like normal function a return type and a list of parameters, overloaded operators functions have the same number of parameters as the operator operands. If an operator function is a member function the first (left-hand) operator is bound to the implicit `this` pointer. Therefore an operator function would have one less parameter than operator operands. An operator is either a member of the *class*, or having a parameter of type *class*.
> **member vs nonmember operator:**
> When we define an operator as a member function, then the left-hand operand must be an object of the class of which that operator is a member. 